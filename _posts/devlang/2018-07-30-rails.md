---
layout:     post
title:      "Rails 学习"
date:       2015-07-12
categories: devlang
author:     "xuanfour"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - rails
---

# Rails 学习

## 目录

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
**Table of Contents**

- [Rails 学习](#rails-学习)
    - [目录](#目录)
    - [Rails 命令](#rails-命令)
        - [命令缩写](#命令缩写)
        - [新建项目](#新建项目)
        - [设置时区](#设置时区)
    - [Rails 项目的目录结构](#rails-项目的目录结构)
        - [app/](#app)
            - [app/controllers](#appcontrollers)
            - [app/models](#appmodels)
            - [app/views](#appviews)
            - [app/helpers](#apphelpers)
            - [app/assets](#appassets)
        - [config/](#config)
        - [db/](#db)
        - [lib/](#lib)
            - [lib/tasks](#libtasks)
        - [log/](#log)
        - [public/](#public)
        - [bin/](#bin)
        - [test/](#test)
        - [tmp/](#tmp)
            - [vendor/assets](#vendorassets)
        - [其他根目录下的档案](#其他根目录下的档案)
    - [多重环境](#多重环境)
    - [Rails 指令](#rails-指令)
        - [generate 可缩写为 g](#generate-可缩写为-g)
        - [console 可缩写为 c](#console-可缩写为-c)
        - [server 可缩写为 s](#server-可缩写为-s)
        - [new](#new)
        - [其他指令](#其他指令)
    - [Rails 启动与应用程式设定](#rails-启动与应用程式设定)
        - [其他初始设定档(initialzers)](#其他初始设定档 initialzers)
            - [filter_parameter_logging](#filterparameterlogging)
            - [backtrace silencers](#backtrace-silencers)
            - [inflections](#inflections)
            - [mime_types](#mimetypes)
            - [sesssion_store](#sesssionstore)
        - [config/secrets.yml](#configsecretsyml)
    - [环境设定档](#环境设定档)
        - [Development 模式](#development-模式)
        - [Production 模式](#production-模式)
        - [Test 模式](#test-模式)
    - [数据库设定档 database.yml](#数据库设定档-databaseyml)
    - [Bundler 与 Gemfile 设定档](#bundler-与-gemfile-设定档)
        - [安装及更新 Gems](#安装及更新-gems)
        - [打包 Gems](#打包-gems)
    - [名称惯例](#名称惯例)
        - [类别命名与自动加载](#类别命名与自动加载)
        - [Model 命名](#model-命名)
        - [Controller 命名](#controller-命名)
        - [View 命名](#view-命名)
    - [Rails 元件导览](#rails-元件导览)
        - [Action Pack](#action-pack)
        - [Action Controller](#action-controller)
        - [Action View](#action-view)
        - [Action Dispatch](#action-dispatch)
        - [Action Mailer](#action-mailer)
        - [Active Model](#active-model)
        - [Active Record](#active-record)
        - [Active Support](#active-support)
        - [Railties](#railties)
    - [Rails 主要对象](#rails-主要对象)
        - [Environment](#environment)
            - [环境判断](#环境判断)
            - [生成生产环境数据库](#生成生产环境数据库)
            - [启动生产环境](#启动生产环境)
        - [Active Record](#active-record-1)
            - [Model](#model)
        - [Route](#route)
            - [REST 具名路由](#rest-具名路由)
            - [route 路由表](#route-路由表)
        - [View](#view)
            - [Rails 的常用前端技术](#rails-的常用前端技术)
            - [参数传递](#参数传递)
            - [调试](#调试)
            - [闪现消息](#闪现消息)
    - [杂项](#杂项)
        - [方法](#方法)
        - [符号 Symbol](#符号-symbol)
        - [数组 Array](#数组-array)
        - [值域 Range](#值域-range)
        - [散列 Hash](#散列-hash)
        - [块](#块)
        - [类](#类)
            - [具名构造方法](#具名构造方法)
            - [类的初始化](#类的初始化)
            - [类的继承](#类的继承)
            - [修改类](#修改类)
    - [常用方法](#常用方法)
        - [`String.split`](#stringsplit)
        - [`Array.join`](#arrayjoin)
        - [`String.downcase`](#stringdowncase)
        - [`String.upcase`](#stringupcase)
        - [`String.reverse`](#stringreverse)
        - [`Array.shuffle`](#arrayshuffle)
        - [`Object.inspect`](#objectinspect)
        - [`Object.class`](#objectclass)
        - [`Class.superclass`](#classsuperclass)
        - [`Hash.merge(other_hash)`](#hashmergeotherhash)
        - [`singularize` 和 `pluralize`](#singularize-和-pluralize)
        - [`head`、`render` 和 `redirect_to`](#headrender-和-redirectto)
        - [`redirect_back`](#redirectback)
    - [Tips](#tips)
        - [require 引用文件路径方法与问题总结](#require-引用文件路径方法与问题总结)
            - [引用一个文件](#引用一个文件)
            - [引用一个目录下所有文件](#引用一个目录下所有文件)
        - [其他](#其他)
    - [References](#references)

<!-- markdown-toc end -->

## Rails 命令

### 命令缩写

| 完整命令       | 缩写命令 |
| --------       | -------- |
| bundle install | bundle   |
| rails server   | rails s  |
| rails console  | rails c  |
| rails generate | rails g  |
| rails test     | rails t  |

### 新建项目

```bash
# 创建新的项目
rails new sample_app
cd sample_app

# 编辑 Gemfile
vim Gemfile

# 安装 gem
bundle install --without production
bundle update

# 编辑说明文件
vim README.md

# 初始化 Git 仓库
# git init
git add -A
git commit -m 'init'

# 启动服务，使用 C-c 中断服务
bin/rails server

# 如果有远程仓库
git remote add origin git@<url>:<user>/<repo>.git
# 如果首次推送使用
git push -u origin --all
# 如果再次推送使用
git push

# 有大的变更前最好新建一个分支
git checkout -b <branch-name>
# 首次推送分支到远程仓库
git push -u origin <branch-name>
# 修改完成后提交并合并到主分支
git add -A
git commit -m 'finish xxx'
git checkout master
git merge <branch-name>

# 生成控制器，命令的控制器名使用驼峰式，创建的控制器文件名是蛇底式
bin/rails generate controller <ControllerName> <action_name>
# 撤销前一个命令
bin/rails destroy controller <ControllerName> <action_name>

# 生成模型
bin/rails generate model <ModelName> <attr_name>:<type>
# 撤销前一个命令
bin/rails destroy model <ModelName>

# 生成数据迁移
bin/rails db:migrate
# 撤销前一个命令
bin/rails db:rollback
# 回到最开始的状态，下面的 `0` 可以修改为其他数字以回到相应版本
bin/rails db:migrate VERSION=0

# 修改 `config/routes.rb` 增加控制器动作的路由
# 将发给 `<controller>/action` 的请求映射到控制器动作。另外，get 表达这个路由响应的是 Get 请求。
get `<controller>/action`

# 集成测试
bin/rails generate integration_test site_layout

# 生成测试数据，编辑文件 `test/fixtures/xxxx.yml`
# `gem faker` 可以用半真实的名字和电子邮件地址创建示例用户
# 向数据库中添加示例用户的 ruby 代码，编辑文件 `db/seeds.rb`
User.create!(name: 'Example User',
             email: 'example@railstutorial.org',
             password: 'foobar',
             password_confirmation: 'foobar')

99.times do |n|
  name = Faker::Name.name
  email = "example-#{n+1}@railstutorial.org"
  password = 'password'
  User.create!(name: name,
               email: email,
               password: password,
               password_confirmation: password)
end

# 还原数据库
bin/rails db:migrate:reset
# 生成示例数据
bin/rails db:seed
```

### 设置时区

设置时区为中国北京，打开 `config/application.rb` 中添加以下两条配置

```ruby
# 显示为北京时间
config.time_zone = "Beijing"
# 存入数据库本地时区时间
config.active_record.default_timezone = :local
# 关闭以 UTC 格式存入数据库并读取以本地时区格式读取的功能
config.active_record.time_zone_aware_attributes = false
```

> [返回目录](#目录)

## Rails 项目的目录结构 ##


### app/ ###

app 目录是你主要工作的地方，不同子目录存放了 Models、Controllers、Views、Helpers 和 Assets 等档案。

#### app/controllers ####

Controller 的类别档案存放在这里

#### app/models ####

Model 的类别档案存放在这里

#### app/views ####

View 的样本(template)档案，依照不同 Controllers 分子目录存放。

#### app/helpers ####

Helper 一些在 Views 中可以使用的小方法，用来产生较复杂的 HTML。默认的 Helper 档案命名是对应 Controller 的，不过并不强制，定义在任一个 Helper 档案中的方法，都可以在任何 Views 中使用。

#### app/assets ####

Assets 静态档案存放在这里，包括有 JavaScript、Stylesheets 样式表和 Images 图档。详细的用法会在 Assets 一章中介绍。

### config/ ###

虽然 Rails 的原则是惯例优于设定，不过还是有一些需要设定的地方。这个目录下存放了例如数据库设定档 database.yml、路由设定 routes.rb、应用程式设定档 application.rb 和不同执行环境的设定档在 config/environments 目录下。

### db/ ###

数据库 Schema(纲要) 和定义档 migrations

### lib/ ###

如果你有一些共享的类别或模块档案，可以放在这里，然后用 require 加载。例如一个放在 lib/foobar.rb 的类别或模组档案，可以在要使用的 .rb 档案中这样加载：

``` rails
require "foobar"
```

如果放在子目录 lib/foo/bar.rb 的话：

``` rails
require "foo/ba
```

#### lib/tasks ####

Rake 任务档案存放在这里，我们会在 Rails 锦囊妙计 一章介绍 Rake。

### log/ ###

不同执行环境的 log 档案会分别记录在这里

### public/ ###

这个目录对 Web 服务器来说，就是文件根目录(document root)，也就是唯一可以在网络上读取到的目录。

### bin/ ###

Rails 的脚本档案，例如执行 bin/rake。

### test/ ###

单元测试、功能测试及整合测试的档案。本书会改用 RSpec 做测试，所以这一个目录会被砍掉。RSpec 的测试档案会放在 spec/目录下。

### tmp/ ###

. 用来存放暂时用途的档案

#### vendor/assets ####

可将第三方的 CSS/JavaScript 函式库(没有提供 Gem 安装版本的)复制一份放在这里。

### 其他根目录下的档案 ###

- config.ru 用来启动应用程式的 Rack 设定档
- Gemfile 设定你的 Rails 应用程式会使用哪些 Gems
- README.md 你的应用程式使用手册。你可以用来告诉其他人你的应用程式是做什么用的，如何使用等等。这会是 Github 上的专案首页。
- Rakefile 用来加载可以被命令列执行的 Rake 任务

## 多重环境 ##

Rails 应用程式默认提供了三种不同的执行模式：

- development environment 开发模式，用在你的开发的时候
- test environment 测试模式，用在执行测试程式时
- production environment 正式上线模式，用在实际的上线运作环境

不同环境的差异在于有不同的设定，除了数据库设定 database.yml 里分开设定之外，个别的环境设定放在 config/environments/development.rb、config/environments/test.rb 和 config/environments/production.rb，它们可以有不同的 Log 层级、Session 设定、Email 设定等等。除了默认的这三种模式，我们也可以自定模式，只需要建立对应的档案即可，例如 config/environments/staging.rb。我们会在下一节详述这些档案里面的设定。

staging 可以用来表示准上线模式，用来做正式上线前的 QA 测试用途。

因为程式本身是不是写死是哪一种执行模式，那么要怎么区分呢？根据不同情况有不同方法，包括：

根据环境变量 RAILS_ENV 或 RACK_ENV 来决定使用哪一种模式，例如使用 rake 时：

``` rails
RAILS_ENV=production bin/rake db:migrate
```

指令根据参数决定:

``` rails
bin/rails console production
bin/rails server -e production
```

最后，应用程式服务器则看服务器设定档，例如 Passenger 里会设定 RackEnv 参数，布署一章会详细介绍。

## Rails 指令 ##

我们已经陆续使用过一些指令了，让我们看看全部的指令吧：

### generate 可缩写为 g ###

产生各种不同类型的档案，例如

``` rails
bin/rails generate model person
bin/rails g controller people
```

### console 可缩写为 c ###

开启一个 Rails 主控台

``` rails
bin/rails console
bin/rails c
```

默认的环境是 developement，如果需要指定环境，请多输入环境名称即可，例如：

``` rails
bin/rails c production
```

Rails 也有提供沙箱模式(Sandbox)，任何数据库的修改都会在离开时回复(原理是数据库 Transaction)：

``` rails
bin/rails c --sandbox
```

在主控台中输入 exit 就会离开。

### server 可缩写为 s ###

开启一个 Rails 服务器

``` rails
bin/rails s
```

默认是使用 Port 3000 和 development 环境，如果需要指定：

``` rails
bin/rails s -p 4000 -e production
```

### new ###

建立一个新 Rails 专案

``` rails
bin/rails new my_app
```

将会建立一个叫做 MyApp 的 Rails 专案在 ./my_app 目录下。加上--database 参数可以改变设定档的默认值，例如：

``` rails
bin/rails new my_app --database=mysql
```

其他说明可以输入 rails 看到全部的指令。

### 其他指令 ###

- dbconsole 开起一个数据库主控台 (可简写为 rails db)，让你直接输入 SQL 指令。
- destroy 删除 “generate” 所产生的档案
- runner 在 Rails 环境中执行一段程式，例如 rails runner “puts Person.count”

## Rails 启动与应用程式设定 ##

不同的 Rails 版本产生的设定档可能会略有差异，这些设定档也没有列出所有 Rails 设定，只有列出比较常用的。

启动整个 Rails 程序(包括 rails server, rails runner, rails console 等) 时，会执行 application.rb 的应用程式设定，让我们来看看这个档案一些比较重要的部分吧。如果你对这个档案有修改，无论在什么模式下，都必须重新启动 Rails 设定才会生效。

``` rails
# Set Time.zone default to the specified zone and make Active Record auto-convert to this zone.
# Run "rake -D time" for a list of tasks for finding time zone names. Default is UTC.
# config.time_zone = 'Central Time (US & Canada)'
```

设定默认的应用程式时区，默认是 UTC。在 Rails 中，数据库里面储存的时间皆为 UTC 时间，而设定此时区会自动帮你处理转换动作。例如设定 Taipei 的话，从数据库读取出来时会自动加八小时，存进数据库时会自动减八小时。

``` rails
# The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.
# config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]
# config.i18n.default_locale = :de
```

设定默认的应用程式语系，默认是:en。在“I18n 多国语系及时区”查询如何使用。

### 其他初始设定档(initialzers) ###

如果将所有的设定都放到 application.rb 就太混乱了，所以非 Rails 核心的设定，我们会放在 config/initializers 目录下。这个目录下的所有.rb 档案会在 Rails 启动时都会自动加载执行。默认产生的档案有五个：

#### filter_parameter_logging ####

``` rails
# Configure sensitive parameters which will be filtered from the log file.
Rails.application.config.filter_parameters += [:password]
```

设定 filter_paramsters 可以避免任何叫做 password 的参数值记录到 log 中，有效防止使用者的原始密码外洩到 log 档案。

#### backtrace silencers ####

可以让你选择性地移除例外追踪(exception backtrace)讯息，例如有些套件可能会很吵，妨碍你除错。

#### inflections ####

Rails 的命名惯例十分倚赖英文的单复数，例如将单数的类别名称 Person 转成复数的表格名称 people。Inflector 就是负责将字串转换成单复数的类别，虽然它内建了一些基本的转换规格，但是英文常常有例外的时候，你可以在这个档案中加上新的规格来做修正。如果你不太确定 Rails 转换的对不对，请进入 console 主控台试试看：

``` rails
$ rails c
$ Loading development environment (Rails 3.2.8)
$ > "Business".singularize  => "Busines" # 转单数
$ > "moose".pluralize => "mooses"  # 转复数
```

很不幸地这两个例子 Rails 都没转对，这时候你就可以利用 inflections.rb 来修正。

Rails 核心不接受有关单复数转换的单字错误回报，毕竟它不是想做字典。

#### mime_types ####

Rails 默认支援了如下常见的标准 MIME(Multipurpose Internet Mail Extensions) 格式，MIME 被用在 HTTP 通讯协定中的请求标头 Accept 和回应标头 Content-Type 中，来说明此文件的格式。例如 Accept:application/xml,application/xhtml+xml,text/html; 和 Content-Type:text/html; charset=UTF-8。而 Rails 会在 Controller 的 respond_to 方法中辨识并回应所请求的格式样板，例如浏览器请求 application/xml 就会回应 xml 格式

| type/subtype                      | respond_to symbol | 别名/说明                                        |
| text/html                         | :html, :xhtml     | application/xhtml+xml                            |
| text/plain                        | :text, :txt       |                                                  |
| text/javascript                   | :js               | application/javascript, application/x-javascript |
| text/css                          | :css              |                                                  |
| text/calendar                     | :ics              | iCalendar 格式                                   |
| text/csv                          | :csv              |                                                  |
| application/xml                   | :xml              | text/xml, application/x-xml                      |
| application/rss+xml               | :rss              |                                                  |
| application/atom+xml              | :atom             |                                                  |
| application/x-yaml                | :yaml             | text/yaml                                        |
| application/x-www-form-urlencoded | :url_encoded_form | 默认的 HTML forms 格式                           |
| multipart/form-data               | :multipart_form   | HTML forms 格式(包含二进制档案资料)              |
| application/json                  | :json             | text/x-json application/jsonrequest              |

如果你需要定制，可以在这里注册。

#### sesssion_store ####

Rails 默认使用了 Cookie 来储存 Session 讯息。它会用上述的 key 编码之后，直接存放在使用者浏览器 Cookie 上。除了 Cookie Session，我们也可以使用 ActiveRecord 储存在数据库中。我们会在 Controller 一章中详细介绍及比较。

### config/secrets.yml ###

这个设定档包括了乱数产生的一组 secret_key_base 用来编码需要保护的 Cookie 讯息。修改这组 key 会让已经存放在使用者浏览器上的 Cookie Session 和 Signed Cookie 失效。你可以用来强制使用者需要重新登入。

``` rails
development:
  secret_key_base: 8dd8d723d33d474710ab65b....
  some_api_key: SOMEKEY

test:
  secret_key_base: 175fa99b200ba23cf82fec6c....

# Do not keep production secrets in the repository,
# instead read values from the environment.
production:
  secret_key_base: <%= ENV["SECRET_KEY_BASE"] %>
```

除了本来的 secret_key_base 之外，你也可以用这个档案放其他设定，例如第三方应用的 Key 或 Token。上述的例子透过 Rails.application.secrets.some_api_key 方法就会回传 SOMEKEY。

> 请小心这个档案不要将 production 用的 secret 公开，例如上传到 Github 的公开储存库。因为如果有人拿到 secret_key_base 那他就可以破解 Rails 默认的 Cookie-based Session，造成安全上的严重漏洞。一般 Production 环境的作法是会将含有 production 完整设定的 config/secrets.yml 只放一份在服务器上，或是透过环境变量来设定。详细的作法可以参考布署一章。

## 环境设定档 ##

我们在上一节”多重环境设定”曾经介绍不同环境会有不同的设定档，让我们来更深入看看有哪些设定值，以及这些值是如果影响 Development、Production 和 Test 环境的不同：

### Development 模式 ###

``` rails
# In the development environment your application's code is reloaded on
# every request. This slows down response time but is perfect for development
# since you don't have to restart the web server when you make code changes.
config.cache_classes = false
```

使用 Rails 开发可以快速的原因之一，就是当你修改一个小东西，只要重新整理浏览器就可以马上看到修改后的结果。这个秘诀就在于 cache_classes = false 会让每一次的 HTTP 请求都重新加载类别档案。更仔细的说，当这个值是 false 的时候，Rails 会改用 Ruby 的 load 方法，每次执行都会重新加载一次。相反地，如果这个值是 true，则会用 Ruby 的 require 方法，只会在第一次碰到的时候加载，之后碰到 require 相同的档案，就会自动忽略，也就是说如果你启动 Rails 后，档案有修改想看到结果，必须重新启动 Rails 才行，否则无法立即看到结果。

``` rails
# Show full error reports and disable caching
config.consider_all_requests_local = true
```

Rails 只有在连线是来自本地端的时候，才会将发生错误时的 Call stack trace 资讯给浏览器显示。这个设定将所有连线都当做本地端连线，好让开发模式时所有人连线都可以看到错误讯息。

``` rails
config.action_controller.perform_caching = false
```

是否启用 Controller 层级的快取(我们会在 Controller 一章介绍到有哪些快取方法)，一般来说在开发模式不会启用，除非你要测试它。

``` rails
# Don't care if the mailer can't send
config.action_mailer.raise_delivery_errors = false
```

如果寄信失败，是否要丢出例外。建议可以改成 true。

建议可以在开发模式设定 config.action_mailer.perform_deliveries = false，这样就不会真的寄信出去。我们会再 ActionMailer 一章详细介绍如何实作寄信功能。

``` rails
# Print deprecation notices to the Rails logger
config.active_support.deprecation = :log
```

随着 Rails 版本的升级，如果有方法会在之后的版本中移除，deprecation 会提示你如何因应。这里的 :log 表示会记录到 log 档案中。

### Production 模式 ###

``` rails
# The production environment is meant for finished, "live" apps.
# Code is not reloaded between requests
config.cache_classes = true
```

cache_classes = true 表示在 production 中，类别档案加载进内存中就快取起来了，大大获得效能。不像在 development 环境中每一次 HTTP 请求就会重新加载一次。

``` rails
# Full error reports are disabled and caching is turned on
 config.consider_all_requests_local       = false
config.action_controller.perform_caching = true
```

不同于 development，如果在 production 环境出现例外错误，不会显示程式 call stack 讯息，而是回传 public/500.html 页面。

``` rails
# Disable Rails's static asset server (Apache or nginx will already do this)
config.serve_static_assets = false
```

“X-Sendfile” 是网页服务器提供的功能，可以让下载档案的动作完全委派给网页服务器，Rails 送出 X-Sendfile 标头后就毋需再佔住资源。

``` rails
# Force all access to the app over SSL, use Strict-Transport-Security, and use secure cookies.
# config.force_ssl = true
```

是否限制全站必须 SSL 才能使用。

``` rails
# See everything in the log (default is :info)
# config.log_level = :debug
```

我们在 RESTful 应用程式 一章最后介绍了 Logger。这里可以设定 Logger 的层级。默认 production 是 :info，其他则是 :debug

``` rails
# Use a different logger for distributed setups
# config.logger = ActiveSupport::TaggedLogging.new(SyslogLogger.new)
```

可以更换掉 Rails 内建的 Logger，例如换成使用 syslog 的 SyslogLogger。

``` rails
# Use a different cache store in production
# config.cache_store = :mem_cache_store
```

设定不同的快取储存库，默认是 :memory_store，也就是每个 Rails process 各自用内存存放。业界最常用的则是 memcached 内存快取服务器。

``` rails
# Enable serving of images, stylesheets, and javascripts from an asset server
# config.action_controller.asset_host = "http://assets.example.com"
```

默认的静态档案位置是目前主机的 public 目录，你可以透过修改 asset_host 变更位置。例如你的静态档案放在不同台机器或 CDN(Content delivery network) 上。

这就是为什么 Rails 在 View 中会使用 Helper 方法的原因之一，我们不会平舖直叙的写 ，而是使用 <%= image_tag(“rails.png”) %> 目的就在于透过程式来获得修改位置的弹性。其他还包括 stylesheets、javascripts 等静态档案都有 Helper 可以使用。

``` rails
# Disable delivery errors, bad email addresses will be ignored
# config.action_mailer.raise_delivery_errors = false

# Enable locale fallbacks for I18n (makes lookups for any locale fall back to
# the I18n.default_locale when a translation can not be found)
config.i18n.fallbacks = true
```

如果 I18n 翻译档找不到，则找用默认语系的文字。我们会在 I18n 一章详细介绍多国语系功能。

``` rails
# Send deprecation notices to registered listeners
config.active_support.deprecation = :notify
```

将 deprecation 讯息传到 Notifications 频道，你可以用以下程式去订阅这个讯息：

``` rails
ActiveSupport::Notifications.subscribe("deprecation.rails") do |message, callstack|
  # deprecation message
end
```

如果没有订阅的话，就什么事都不会发生。

### Test 模式 ###

``` rails
# Show full error reports and disable caching
config.consider_all_requests_local       = true
config.action_controller.perform_caching = false

# Raise exceptions instead of rendering exception templates
config.action_dispatch.show_exceptions = false
```

不同于 development 或 production 碰到例外会捕捉例外后，给浏览器显示出 call stack trace 或 public/500.html 画面，在 test 模式就不处理，让例外直接爆出。

``` rails
# Tell Action Mailer not to deliver emails to the real world.
# The :test delivery method accumulates sent emails in the
# ActionMailer::Base.deliveries array.
config.action_mailer.delivery_method = :test
```

测试模式下不会真的去寄送 email

``` rails
# Print deprecation notices to the stderr
config.active_support.deprecation = :stderr
```

让 deprecation 讯息会直接显示到视窗之中。

## 数据库设定档 database.yml ##

几乎每一个 Rails 应用程式都会与数据库互动。而数据库需要一个设定档是 config/database.yml。如果你打开这个档案，你会发现默认设定是 SQLite3。这个档案包含三个不同的部分，对应到三个 Rails 默认环境。

一个 Mysql 的设定档范例如下：

``` rails
development:
  adapter: mysql
  encoding: utf8mb4
  database: blog_development
  username: root
  password:
production:
  adapter: mysql
  encoding: utf8mb4
  database: blog_production
  username: root
  password:
test:
  adapter: mysql
  encoding: utf8mb4
  database: blog_test
  username: root
  password:
```

## Bundler 与 Gemfile 设定档 ##

Bundler http://gembundler.com/ 是管理应用程式 Gem 依存性(dependencies)管理工具，它会根据 Gemfile 的设定自动下载及安装 Gem 套件，并且帮你解决不同套件之间的依存关系，更重要的是，它可以让不同开发者之间和布署时，所有依存套件的版本都能够一致。

在 Rails3 之后要使用的 Gems，都必须宣告在 Gemfile 设定档中，没写在里面的话，就算手动 require 也找不到。这跟 Rails2 以前可以直接 require 任意 rubygems 不同，在使用 Bundler 的环境中，要 require 什么 rubygems 必须透过 Gemfile 管理。

> Bundler 不只用在 Rails，其他例如 Sinatra 或是旧版 Rails2 也都可以使用

Gemfile 的写法说明如下：

``` rails
# 第二个参数可以指定版本
gem "rails", "5.1.0"

# 也可以不指定版本，这样会安装最新的稳定版本 (不包括 .pre 或 .rc 结尾的版本)
gem 'mysql2'

# 如果 require 的档名不同，可以加上 :require
gem 'yajl-ruby', :require => 'yajl'

# 可以用 Git 当做来源(根目录要有 .gemspec 档案)，甚至可以指定 branch, tag 或 ref。
gem 'authlogic', :git => 'git://github.com/odorcicd/authlogic.git',
                          :branch => 'rails3'

# 也可以直接用电脑里的其他目录
# gem "rails", :path => '/Users/ihower/github/rails'

# Group 功能可以让特定环境才会加载
group :development, :test do
    gem "rspec", "~> 2.0"
    gem "rspec-rails", "~> 2.0"
end
```

版号的指定方式除了指定特定版本，还可以指定大于等于 >= 某个版本。不过最建议的方式则是使用 ~> 的语法。”~> x.y.z” 的意思是版号 x,y 固定，但可以大于等于 z。例如 “~> 1.3.5” 的意思是 1.3.5, 1.3.6, 1.3.9 可以安装，但是 1.4.0, 1.5.5, 2.0.1 就不行。这种写法的好处是，通常版号的命名有其惯例：x major 版号升级表示有 API 发生不向后的相容性变动，y minor 版号升级表示有功能新增，z tiny 版号升级表示 bugs 修正。因此 “~> x.y.z” 可以让我们保有升级弹性，又不致于升级太多让程式发生不相容错误。这种命名是开放源码社群的惯例，叫做 Semantic Versioning。

### 安装及更新 Gems ###

如果你修改了这个档案，请执行 bundle install，这样 Bundler 就会检查并安装这些函式库，并产生一个 Gemfile.lock 档案。Gemfile.lock 档案会详细列出所有使用到的套件版本，你应该把这个档案也 commit 送进版本控制系统，这样其他开发者及上线的版本就都会安装完全一样的版本了。

执行 bundle update gem_name 则会更新此 gem 的版本。bundle update 则会检查所有的 gem 更新到最新版本。一般来说你只需要在每次 Gemfile 修改后，执行 bundle install 即可。如果有套件关连性 bundle install 无法解决，它会提示你执行 bundle update。

什么时候该执行 bundle install 或 bundle update 呢？一般来说，总是执行 bundle install 即可。这个指令只会做必要的更新到 Gemfile.lock，执行速度较快，它不会帮你升级现有的 Gem。而 bundle update 会重新产生整个 Gemfile.lock 档案，更新所有 Gem 到最新版本。但是，一次升级太多套件，可能会造成除错上的困难。因此会建议如果要升级，请执行 bundle update gem_name 一次升级一个套件。

怎么知道可以升级哪些 Gem 呢？

``` rails
bundle outdated
```

这个指令就会列出有新版本可以升级的 gems。

如果你想知道打开套件的原始码，可以输入：

``` rails
bundle open GEM_NAME
```

这样就会用默认的编辑器打开了。

如何设定默认编辑器呢? 如果你使用 Mac 和 Bash 的话，编辑~/.bash_profile 加上 export EDITOR="vim"这样就会用 VIM 当作默认编辑器。

### 打包 Gems ###

执行以下指令，会将所有用到的 Gems 打包进 vendor/cache 目录。如此执行 bundle install 时就不会连线到 http://rubygems.org 下载套件。

``` rails
bundle package
```

什么时候需要用到这个功能呢？例如你希望布署的时候避免外部连线，或是你有非公开的 gems 不会上传到 http://rubygems.org 网站上。

如果你有非 Rails 的 script 需要执行(也就是放在 Gemfile 档案中的 Gem 所自行提供的执行档)，使用 bundle exec 可以正确的加载 Bundler 的环境。例如 bundle exec rspec spec/

## 名称惯例 ##

在 Rails 中有一些命名上的惯例：

### 类别命名与自动加载 ###

档名使用小写、单数，用底线区隔。例如当 Rails 看到一个 OrderItem 的类别或模组(Module)，它会在 Rails 设定的自动加载目录(包括 app/models 和 app/models/concerns 等等)中去加载叫做 order_item.rb 的档案，也就是自动 require “order_item”。

如果是有嵌套的类别或模组，例如 Admin::OrderItem，则会多一层目录，例如加载 app/models/admin/order_item.rb 的档案，也就是自动 require “admin/order_item”。

如果你想要新增目录到 Rails 设定的自动加载目录，可以编辑 config/application.rb 加上

config.eager_load_paths += %W( #{config.root}/lib )
这样就会自动加载 lib 目录了。如果你没有设定 eager_load_paths，或是你的档案没有依照惯例命名，那么你会需要在程式中手动 require 它。基本上，只要依照命名惯例，你不太需要在程式中写 require。

eager_load_paths 目录是指 Rails 会自动根据命名惯例加载，而 Ruby 的 $LOAD_PATH 常数则是 require 时会寻找的目录。像 lib 这个目录 Rails 默认就只有加到 $LOAD_PATH 之中，所以你放在 lib 的档案是可以 require 到，但是因为默认没有加到 eager_load_paths 之中，所以没有自动加载的机制。

### Model 命名 ###

类别名称使用大写、单数，没有底线。而档名使用小写、单数，用底线。数据库表格名称用小写且为复数。例如：

- 数据库表格 line_items
- 档名 app/models/line_item.rb
- 类别名称 LineItem

### Controller 命名 ###

假设有一个 stores controller 的话：

- 档名 app/controllers/stores_controller.rb
- 类别名称 StoresController

如果需要将 controllers 档案做分类，这时候可以使用 Module，将档案放在子目录下，例如后台专用的 controllers：

- 档名 app/controllers/admin/stores_controller.rb
- 类别名称 Admin::StoresController

### View 命名 ###

例如一个叫做 People 的 controller，其中的 index action：

- 档名 app/views/people/index.html.erb
- Helper 名称 module PeopleHelper
- 档名 app/helpers/people_helper.rb

## Rails 元件导览 ##

Rails 包含许多个别的函式库元件：

- Action Pack
- Action Controller
- Action Dispatch
- Action View
- Action Mailer
- Active Model
- Active Record
- Active Support
- Railties

### Action Pack ###

Action Pack 是个包含 Action Controller、Action View 和 Action Dispatch 的 gem。也就是 “MVC” 中的 “VC” 部分。

### Action Controller ###

Action Controller 是 Rails 应用程式中，管理 Controllers 的元件。Action Controller 框架处理传给 Rails 的 HTTP 请求，萃取出参数，然后分派给所属的 Action。Action Controller 还提供了 session 管理、样板演算显示(template rendering) 和 redirect 功能。

### Action View ###

Action View 负责 Rails 应用程式中的 Views。它默认可以产生 HTML 或 XML 输出。Action View 负责样板的演算显示(template rendering)，包括嵌套(nesting)或局部(partial)样板，甚至也内建支援一些 Ajax。

### Action Dispatch ###

Action Dispatch 处理 HTTP 请求的路由(routing)，它把 HTTP 请求发派(dispatch)到它该去的地方，也许是你的应用程式或其他 Rack 程式。

### Action Mailer ###

Action Mailer 是个建构 E-mail 功能的框架。你可以使用 Action Mailer 来接收来信，或是使用样板来寄出纯文字或复杂的 multipart 信件。

### Active Model ###

Active Model 在 Action Pack gem 和 ORM gem (例如 Active Record) 之间定义了一组接口。Active Model 允许 Rails 可以依你的需求把 Active Record 换成其他 ORM 框架。

### Active Record ###

Active Record 是 Rails 应用程式中的 Models 基础。它不依存特定的数据库系统，提供了 CRUD 功能、先进的查询能力以及可以跟其他 Models 关联的本事。

### Active Support ###

Active Support 是 Rails 里的工具函式库，它也扩充了一些 Ruby 标准函式库。除了被用在 Rails 核心程式中，你也可以在你的程式中使用。

### Railties ###

Railties 是 Rails 的核心程式码，用来把以上各种的框架函式库以及 Plugin 全部组合在一起。

> [返回目录](#目录)

## Rails 主要对象

### Environment

#### 环境判断

``` rails
Rails.env.development?
Rails.env.test?
Rails.env.production?
```

#### 生成生产环境数据库

``` bash
rails db:migrate RAILS_ENV=production
```

#### 启动生产环境

``` bash
rails server -- environment production
```

### Active Record

#### Model

``` rails
# 新建模型对象
user = User.new(...)
# 存入数据库
user.save
# 新建模型对象并存入数据库
user = User.create(...)
# 从数据库中删除模型对象
user.destroy

# 查找 id=1 的对象
User.find(1)
# 查找 name='xuan'的对象
User.find_by(name: 'xuan')
# 查找第一个
User.first
#查找所有，返回结果类似数组，但并不是，属于 User::ActiveRecord_Relation
User.all

# 更新对象数据
user.name = 'zhang'
user.save
# 同时更新对象的多个数据属性，并且不做数据校验
user.update_attributes(name: 'zhang', email: 'zhang@test.com')
# 重新加载数据
user.reload

# 在模型对象类增加验证
class User < ApplicationRecord
  validates :name, presence: true, length: { maximum: 50 }
end

# 验证对象
user = User.new(...)
puts user.errors.full_messages unless user.valid?

# 用户密码设置与验证
# 用户 model 设置
has_secure_password
validates :password, presence: true, length: { minimum: 6 }
# 新建用户
User.create(name: username, email: useremail, password: userpassword, password_confirmation: userpassword)
# 密码正确，返回用户对象，否则返回 false
user.authenticate(userpassword)
# 密码正确，返回 true
!!user.authenticate(userpassword)

```

### Route ###

#### REST 具名路由

将 RESTful 带入 Rails 路由系统的点子，出自它对应了 HTTP 动词 POST、GET、PATCH/PUT、DELETE 到资料的新增、读取、更新、删除等四项操作。

手工 CRUD 的路由：

- /users/create
- /users/show/1
- /users/update/1
- /users/destroy/1

RESTful CRUD 路由：

- POST   /users   对应到 Controller 中的 create action
- GET    /users/1 对应到 Controller 中的 show action
- PATCH  /users/1 对应到 Controller 中的 update action
- DELETE /users/1 对应到 Controller 中的 destroy action

什么是 HTTP method？在 HTTP 通讯协定中制定了九种动词(Verbs)来跟服务器沟通，分别是 HEAD、GET、POST、PUT、PATCH、DELETE、TRACE、OPTIONS、CONNECT。其中最常见的就是 GET 和 POST：GET 用来读取资料，这个动作不应该造成任何资料变更。而 POST 用于送出资料，这个动作不会被快取。而因为 HTML 只能送出 GET 或透过表单送出 POST，Rails 为了突破这个限制，在 POST 加上一个隐藏参数_method=PATCH 或_method=DELETE 就可以当做 PATCH 和 DELETE 请求了。

| HTTP 请求 | URL           | 动作    | 具名路由             | 作用               |
| --------  | ----          | ----    | --------             | ----               |
| get       | /users        | index   | users_path           | 显示所有用户的页面 |
| get       | /users/new    | new     | new_user_path        | 创建新用户的页面    |
| get       | /users/1/edit | edit    | edit_user_path(user) | 编辑用户的页面     |
| post      | /users        | create  | users_path           | 创建新用户         |
| get       | /users/1      | show    | user_path(user)      | 显示用户的页面     |
| patch/put | /users/1      | update  | user_path(user)      | 更新用户信息       |
| delete    | /users/1      | destroy | user_path(user)      | 删除用户           |

#### route 路由表

在 route.rb 文件中定义路径会产生具名路由，一般有两种形式：

- `action_path` 表示短路径 `/action`。通常在 `link_to` 的时候使用。
- `action_url` 表示全路径 `http://localhost/action`。通常在 `redirect_to` 的时候使用。

路由定义样例：

``` rails
root 'pages#action'
get 'pages/help'
get '/about', to: 'pages#about'
get '/home', to: 'pages#home' as myhome
resources microposts, only: [:create, :destroy]
resources users do
  member do
    get :following, :followers
  end
  collection do
    get :tigers
  end
end
```

| HTTP 请求 | URL                | 动作      | 具名路由               |
| --------  | ----               | ----      | --------               |
| get       | /users/1/following | following | following_user_path(1) |
| get       | /users/tigers      | tigers    | tigers_user_path       |
|           |                    |           |                        |


> [返回目录](#目录)

### View

#### Rails 的常用前端技术

- jQuery
- UJS
- Assets pipeline
- SJR( 服务端 JS 生成技术 )
- Turoblinks( 一种极小成本实现的单页效果的技术 )

#### 参数传递

params 是一个嵌套散列，包含每次请求的信息。
不能直接使用 params 批量赋值，有漏洞，需要通过下列方法获取：

``` rails
params.require(:user)permit(:name, :email, ...)
```

#### 调试

通过在 `application.html.erb` 里增加下列语句在页面展示调试信息：

``` rails
<%= debug(params) if Rails.env.development? %>
```

通过在控制器增加 `debugger` 方法，可以在控制台服务窗口运行调试命令，需要安装 `byebug gem`，按快捷键 `C-D` 退出。

> [返回目录](#目录)

#### 闪现消息

在 rails 中，短暂显示一个消息使用闪现消息实现。按照约定，flash 用于在两个 action 间传递临时数据，flash 中存放的所有数据会在紧接着的下一个 action 调用后清除。一般用于传递提示和错误信息。


``` rails
flash = { success: "It worked!", danger: "It failed." }
```
一共有两种通知：notice 与 alert，分别表示“提示”和“错误警告”。

- flash[:notice] 与 flash[:alert] 有多种写法：
- flash.notice= 与 flash.alert=
- flash["notice"] 与 flash["alert"]
- redirect_to 时作为参数 :alert => “…”, :notice => “…”

另外一个还会遇到的是 flash.now[]，它只对当前 action 有效，用于重新渲染的页面，下一个 action 即无效。

- flash.now[:message] = “Hello current action”
- flash.now[]设置的数据访问方法与其它相同：均为 flash['my-key'**

**原理：***

flash.now[** 是保存在 request 中的。
alert 与 notice 是保存在 session 中的, 只是获取数据时添加了删除的逻辑。

**注意：***

- flash[:alert],flash[:notice]一般与 redirect_to 一起用，而不能与 render 一起用。
- redirect_to 是重定向，会重新发起请求，比 render 多了一次请求。flash[:alert],flash[:notice]只会出现在接下面的一个页面中。
- 而 render 是服务器端转发，客户端不会重新发送请求，比 redirect_to 少了一次请求。所以一旦一起用，结果是接下来两个页面都有 flash[:alert],flash[:notice]，第三个页面时才会消失。
- 正确的做法是 render 搭配 flash.now[:alert],flash.now[:notice]一起用

显示所有 notice 与 alert 的 helper

application_helper.rb 中添加：

``` rails
def display_notice_and_alert
  msg = ''
  msg << (content_tag :div, notice, :class => "notice") if notice
  msg << (content_tag :div, alert, :class => "alert") if alert
  sanitize msg
end
```

view 中只需添加：

``` rails
<%= display_notice_and_alert %>
```

> [返回目录](#目录)

## 杂项

### 方法

* 方法后缀感叹号，表示会修改对象的值。

### 符号 Symbol

* 符号可以简单看作没有约束的字符串，符号是整体的，比较的时候只比较一次，不像字符串需要每个字符去比较。
* 符号的命名一般是字母、下划线、数字，数字不能用于首位。

``` ruby
symb = :symbol
```

### 数组 Array

```ruby
arr = [0, 1, 2]
chs = %w[a b c]
```

* 数组的索引可以是负数，`-1` 是最后一个数组项。
* `%w` 用于创建元素为字符串的数组。

### 值域 Range

```ruby
val = 0..3
arr = ('a'..'g').to_a
av = arr[val]
```

### 散列 Hash

* 散列（Hash）本质上就是数组，只不过它的索引不局限于只能使用数字。三列的索引几乎可以使用任何对象，一般我们称之为“键值”。
* 调用方法时，如果散列是最后一个参数，可以省略花括号。

``` ruby
# 空散列
user = { }
# 键为 ":first_name"，值为 "Michael"
user[:first_name] = 'Michael'

# 散列的定义
ha = { 'name' => 'Bob', 'age' => 33 }
# 符号做键值的时候散列的定义可以使用简洁的语法
hasym = { name: 'Bob', age: 33}

# 散列迭代
hasym.each do |key, value|
  puts "Key #{key.inspect} has value #{value.inspect}"
end
```

### 块

```ruby
(1..5).each { |i| puts 2 * i }

(1..5).each do |i|
  puts 2 * i
end
```

### 类

#### 具名构造方法

```ruby
Object.new
String.new
Array.new
Range.new(m, n)
Hash.new
```

#### 类的初始化

```ruby
class User
  attr_accessor :name, :age

  def initialize(args = {})
    @name = args[:name]
    @age  = args[:age]
  end
end
```

#### 类的继承

* Ruby 的类继承：`String->Object->BasicObject`。
* 类定义里，self 代表的是对象本身。

```ruby
class MyClass < Object
end
```

#### 修改类

```ruby
class String
  # 回文字符串返回 true
  def palindrome?
    self == self.reverse
  end
end
```

> [返回目录](#目录)

## 常用方法

### `String.split`

字符串拆分成数组。

### `Array.join`

数组组合成字符串。

### `String.downcase`

返回小写字符串。

### `String.upcase`

返回大写字符串。

### `String.reverse`

反转字符串内容。

### `Array.shuffle`

返回乱序数组。

### `Object.inspect`

返回被调用对象的字符串字面量。

### `Object.class`

返回类。

### `Class.superclass`

返回类的父类。

### `Hash.merge(other_hash)`

返回一个新的散列，新散列是两个散列的合集，如果散列的键有重复，那么以 other_hash 的值为新散列的值。

### `singularize` 和 `pluralize`

- `singularize` 获得一个字符串的单数
- `pluralize` 获得一个字符串的复数

### `head`、`render` 和 `redirect_to`

从控制器的角度来看，创建 HTTP 响应有三种方法：

- 调用 `render` 方法，向浏览器发送一个完整的响应；
- 调用 `redirect_to` 方法，向浏览器发送一个 HTTP 重定向状态码；
- 调用 `head` 方法，向浏览器发送只含报头的响应；

从执行来看，有两种方式：

- `render` 是渲染，只是渲染了一个新的模版，没有执行相应的 action 方法。
- `redirect_to` 是跳转，实现 action 方法的跳转，向浏览器发起一个新的请求。

当 Rails 程序运行到 redirect_to 时，需要等待浏览器发送一个新的 http 请求再继续执行后面的代码。服务器发送 302 HTTP 状态码到浏览器并重定向，客户端(用户浏览器)将发送一个新的请求到服务器，action 将被执行。
运行 render 时不会执行指定 action 的代码，直接渲染页面。

控制器中的代码执行到 render 和 redirect_to 时，如果两者不是放在最后，并不会跳出并结束当前 action。

当涉及到表单提交时，数据库记录更新成功使用 redirect_to，更新失败使用 render 除了避免表单重复提交之外，如果表单提交失败，之前表单填写的信息还会存在，增强用户体验。

### `redirect_back`

`redirect_back(fallback_location: jump_path)`回到上一次访问的页面，如果 HTTP_REFERER 来源不存在，跳转到参数指定的位置。

> [返回目录](#目录)

## Tips

### require 引用文件路径方法与问题总结

同一目录下的文件，如/usr/local/ruby/foo.rb 与/usr/local/ruby/bar.rb 两个文件。
如果直接在 foo.rb 中 `require 'bar'` 执行时会报找不到 bar.rb 错误。
这是因为运行 ruby /usr/local/ruby/foo.rb 时会在 ruby 安装的 lib 目录和/home/oldsong/目录下查找 bar.rb。而不会去 rb 文件的目录 /usr/local/ruby/ 下查找。所以除引用系统 rb 外，require 中不能用相对路径。

下面介绍几种引用单个和目录下所有 rb 的方法。

#### 引用一个文件 ####

例: 引用当前 rb 同目录下的 file_to_require.rb

- require File.join(__FILE_, '../file_to_require')。
- require File.expand_path('../file_to_require', __FILE__)
- require File.dirname(__FILE__) + '/file_to_require'

其中，File.expand_path 是 Rails 常用的做法。
__FILE__为常量，表示当前文件的绝对路径，如/home/oldsong/test.rb

``` ruby
$LOAD_PATH.unshift(File.dirname(__FILE__))
require 'bar'
```

先把目录加入 LOAD_PATH 变量中，然后可直接引用文件名。

#### 引用一个目录下所有文件 ####

Ruby 没有 Java 中的 import java.io.*;
引用时不能用通配符，估计以后的版本有可能加上。

例：引用当前 rb 相同目录下 lib/文件下所有*.rb 文件。

``` ruby
Dir[File.dirname(__FILE__) + '/lib/*.rb'].each {|file| require file }
```

使用 gem 搞定

https://rubygems.org/gems/require_all

### 其他

- 左值不能省略 self

> [返回目录](#目录)

## References

> 本文是我的学习笔记，内容参考了网上资源，为了方便自己查询使用，做了一些修改整理。
> 笔记内容摘录于下列文章，相应权利归属原作者，如有未列出的或有不妥，请联系我立即增补或删除。

- https://ihower.tw/rails/index-cn.html

> [返回目录](#目录)
