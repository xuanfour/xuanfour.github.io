---
layout:     post
title:      "Ruby 学习"
date:       2015-07-12
categories: devlang
author:     "xuanfour"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - ruby
---

# Ruby 学习 #

## 目录 ##

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
**Table of Contents**

- [Ruby 学习](#ruby-学习)
    - [目录](#目录)
    - [方法](#方法)
        - [方法参数](#方法参数)
            - [可变参数数组](#可变参数数组)
            - [符号散列参数](#符号散列参数)
            - [可变参数符号散列](#可变参数符号散列)
        - [方法调用](#方法调用)
            - [数组分解为参数](#数组分解为参数)
            - [把散列作为参数传递](#把散列作为参数传递)
    - [Include、Extend、Load、Require 的使用区别](#includeextendloadrequire-的使用区别)
        - [Include](#include)
        - [Extend](#extend)
        - [Require](#require)
        - [Load](#load)
        - [map(collect)、each、select、find(detect)、inject、reject](#mapcollecteachselectfinddetectinjectreject)
            - [map（别名函数 collect）](#map 别名函数-collect)
            - [each](#each)
            - [select](#select)
            - [find（别名函数 detect）](#find 别名函数-detect)
            - [inject](#inject)
            - [reject](#reject)
    - [Tips](#tips)
        - [and or not 的优先级](#and-or-not-的优先级)
        - [`*` 号的作用](#-号的作用)
            - [1. 有正常的乘法功能](#1-有正常的乘法功能)
            - [2. 数组 * integer](#2-数组--integer)
            - [3. 字符串 * integer](#3-字符串--integer)
            - [4. 创建数组](#4-创建数组)
            - [5. 可变参数](#5-可变参数)
    - [References](#references)

<!-- markdown-toc end -->

## 方法 ##

### 方法参数 ###

#### 可变参数数组 ####

所有不确定的参数都被作为数组赋值给变量 `args`，`*args` 这种形式的参数，只能在方法定义的参数列表中出现一次。

``` ruby
def foo(first, *args, last)
  [first, args, last]
end

p foo(1, 2, 3, 4, 5)   #=> [1, [2, 3, 4], 5]
```

#### 符号散列参数 ####

符号参数在 Ruby 2.0 中定义。可以使用符号将参数名与参数值成对地传给方法内部使用，设置默认值后不用关心参数个数和参数调用顺序。符号参数可以与普通参数搭配使用。

``` ruby
def foo(arg, x: 0, y: 1, z: 2)
  [arg, x, y, z]
end
```

#### 可变参数符号散列 ####

可以使用 `options = {}` 的形式定义不确定的散列参数，但更推荐采用 Ruby 2.0 中定义的参数使用 `**变量名` 的形式，可以将参数列表以外的关键字参数以散列形式保存。

``` ruby
def foo(x: 0, y: 1, z: 2, **args)
  [x, y, z, args]
end

def bar(x: 0, y: 1, z: 2, options = {})
  [x, y, z, options]
end

foo(z: 11, y: 12, x: 13)                  #=> [11, 12, 13, {}]
foo(z: 11, y: 12, x: 13, a: 1, b: 2)      #=> [11, 12, 13, {:a=>1, :b=>2}]
bar(z: 11, y: 12, x: 13)                  #=> [11, 12, 13, {}]
bar(z: 11, y: 12, x: 13, a: 1, b: 2)      #=> [11, 12, 13, {:a=>1, :b=>2}]
```

### 方法调用 ###

#### 数组分解为参数 ####

调用方法是，如果以 `*数组` 的形式指定参数，这时传递给方法的不是数组本身，而是数组的各元素被按照顺序传递给方法。但需要注意的是，元素个数必须和方法定义的参数个数一致。

``` ruby
def foo(a, b, c)
  a + b + c
end

args = [2, 3]
p foo(1, *agrs)   #=> 6
```

#### 把散列作为参数传递 ####

散列的字面量是 `{}`，将散列的字面量作为最后一个参数传递给方法时可以省略 `{}`。

``` ruby
def foo(arg1, arg2)
  [arg1, arg2]
end

p foo(100, a: 1, b: 2)   #=> [100, {:a=>1, :b=>2}]
```

> [返回目录](#目录)

## Include、Extend、Load、Require 的使用区别 ##

### Include ###

当你 Include 一个模块到某个类时, 相当于把模块中定义的方法插入到类中。它允许使用 mixin。它用来 DRY 你的代码, 避免重复。例如, 当你有多个类时, 需要相同的函数时, 可以把函数定义到 module 中, 进行 include。 下例假设模块 Log 和类 TestClass 在相同的.rb 文件。如果它们存在于多个文件, 则需要使用 load 或 require 导入文件。

``` ruby
module Log
  def class_type
    "This class is of type: #{self.class}"
  end
end

class TestClass
  include Log
end

tc = TestClass.new.class_type
puts tc #This class is of type: TestClass
```

### Extend ###

当你使用 Extend 来替换 Include 的时候, 在类定义中使用的 extend Log 实际是一种简写，实际运行的是 self.extend(Log)。 并不是说使用 Extend 时就是类方法。而是需要注意到我们实际使用的是一种简写，由于是 self(即类本身) 调用了 Extend 这个方法，才使得添加模块中的方法被设定成了类方法。

所以如果希望避免这一误会，可以在类定义中使用 self.extend(module, ...) 而非 extend(module, ...)。

``` ruby
module Mod
    def hello
      "Hello from Mod.\n"
    end
end

class Klass
  def hello
    "Hello from Klass.\n"
  end
end

k = Klass.new
k.hello         #=> "Hello from Klass.\n"
k.extend(Mod)   #=> #<Klass:0x401b3bc8>
k.hello         #=> "Hello from Mod.\n"
```

``` ruby
module Log
  def class_type
    "This class is of type: #{self.class}"
  end
end

class TestClass
  extend Log
  # ...
end

TestClass.new.class # => TestClass
TestClass.class # => Class

tc = TestClass.class_type
puts tc  # => This class is of type: Class
```

当你在类中使用 Extend 来代替 Include, 如果你实例化 TestClass 并调用 class_type 方法时，你将会得到 NoMethodError。再一次强调, 使用 Extend 时方法是类方法。

### Require ###

Require 方法允许你载入一个库并且会阻止你加载多次。当你使用 require 重复加载同一个 library 时，require 方法 将会返回 false。当你要载入的库在不同的文件时才能使用 require 方法。下例将演示 require 的使用方式。

文件 test_library.rb 和 test_require.rb 在同一个目录下。

``` ruby
# test_library.rb
puts " load this libary "
```

``` ruby
# test_require.rb
puts (require './test_library')
puts (require './test_library')
puts (require './test_library')

# 结果为
#  load this libary
# true
# false
# false
```

### Load ###

Load 方法基本和 require 方法功能一致，但它不会跟踪要导入的库是否已被加载。因此当重复使用 load 方法时，也会载入多次。大部分情况你都会使用 require 来代替 load。但当你需要每次都要加载时候你才会使用 load, 例如模块的状态会频繁地变化, 你会使用 load 进行加载，获取最新的状态。

``` ruby
puts load "./test_library.rb"  #在这里不能省略 .rb, require 可以省略
puts load "./test_library.rb"
puts load "./test_library.rb"

#结果
# load this libary
#true
# load this libary
#true
# load this libary
#true
```

> [返回目录](#目录)

### map(collect)、each、select、find(detect)、inject、reject ###

#### map（别名函数 collect） ####

对数组中每个元素进行表达式操作，原始数组不会被改变，返回执行表达式结果的新数组

``` ruby
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map{ |e| e * 3 }
# => [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].collect{ |e| e == 3 }
# =>[false, false, true, false, false, false, false, false, false, false]
```

#### each ####

常用作数组的循环操作，对循环的参数做表达式操作，原数组不会被改变，返回原始数组

``` ruby
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].each{|e| print e.to_s + "###"}
# => 1###2###3###4###5###6###7###8###9###10###=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

#### select ####

相当于过滤器，返回符合表达式元素的新数组，如果所有都不符合表达式则返回空数组

``` ruby
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].select{ |e| e == 3 }
# => [3]

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].select{ |e| e * 3 }
# => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

#### find（别名函数 detect）####

返回列表中第一个符合条件的元素

``` ruby
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].detect{ |e| e == 3 || e == 2 }
# =>  2
```

#### inject ####

在所声明的容器中注入符合条件的元素，通常为累加器作用

``` ruby
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].inject{ |sum, e| sum += e }
# 其中 sum 为所声明的注入器 将累加后的结果最后注入到 sum 中并返回注入器最后结果

[1,2,3,4,5,6,7,8,9,10].inject{ |result, elem| result + elem}
# => 55
# 此时 inject 没有带参数，这是 result 会为数组中第一个元素，elem 为第二个元素，依次累加返回最后结果

{1 => 'a', 2 => 'b', 3 =>'c'}.inject({}){ |key, value| value }
# => [3, "c"]
```

#### reject ####

去除列表中符合条件的元素

``` ruby
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].reject{ |e| e == 2 || e == 8 }
# => [1, 3, 4, 5, 6, 7, 9, 10]
```

> [返回目录](#目录)

## Tips ##

### and or not 的优先级 ###

`and or not` 的优先级较低，而 `&& || !` 的优先级是较高的，在使用中如果没有用括号严格界定的话，容易出问题，尤其是 ` and return`语句，需要注意。

### `*` 号的作用 ###

星号有乘和取元素两种含义。

#### 1. 有正常的乘法功能 ####

``` ruby
3 * 4   #=> 12
```

#### 2. 数组 * integer ####

``` ruby
[1,2 ,[3 , [4 ,5]]] * 2 #=> [1,2 ,[3 , [4 ,5]] , 1,2 ,[3 , [4 ,5]]]
```

#### 3. 字符串 * integer ####

``` ruby
"hello" * 2   #=> "hellohello"
```

#### 4. 创建数组 ####

``` ruby
*a = 1, 3, "as" #=> [1, 3, "as"]
```

#### 5. 可变参数 ####

一个星号表示数组元素迭代，在方法参数定义中可变参数数组。

``` ruby
def foo(*args)
  p args
end

a = [1 , 2]
foo(1, 2)     #=> [1, 2]
foo(*a)       #=> [1, 2]
foo(a)        #=> [[1, 2]]
foo([1, 2])   #=> [[1, 2]]
```

两个星号表示符号散列元素迭代，在方法参数定义中可变参数符号散列。

``` ruby
def foo(**args)
  p args
end

as = {a: 1, b: 2}
foo(a: 1, b: 2)    #=> {a: 1, b: 2}
foo({a: 1, b: 2})  #=> {a: 1, b: 2}
foo(as)            #=> {a: 1, b: 2}
foo(**as)          #=> {a: 1, b: 2}
```

> [返回目录](#目录)

## References

> 本文是我的学习笔记，内容参考了网上资源，为了方便自己查询使用，做了一些修改整理。
> 笔记内容摘录于下列文章，相应权利归属原作者，如有未列出的或有不妥，请联系我立即增补或删除。
- https://ruby-china.org/topics/25706
- http://doudouclever.blog.163.com/blog/static/17511231020110743139240/

> [返回目录](#目录)
